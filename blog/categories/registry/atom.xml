<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Registry | Mike Murray]]></title>
  <link href="http://mkmurray.com/blog/categories/registry/atom.xml" rel="self"/>
  <link href="http://mkmurray.com/"/>
  <updated>2012-12-15T15:41:41-07:00</updated>
  <id>http://mkmurray.com/</id>
  <author>
    <name><![CDATA[Mike Murray]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Custom Setup Bootstrappers]]></title>
    <link href="http://mkmurray.com/blog/2009/11/11/custom-setup-bootstrappers/"/>
    <updated>2009-11-11T15:03:00-07:00</updated>
    <id>http://mkmurray.com/blog/2009/11/11/custom-setup-bootstrappers</id>
    <content type="html"><![CDATA[<div class='post'>
<p>At work, we have a line of desktop products for one of clients installed on the user’s Windows machine via MSI installers.&#160; We use Visual Studio Setup Projects to create the MSI installers.&#160; Visual Studio also provides the ability to create setup bootstrappers to make sure the user has all the prerequisites needed for the MSI install technology and any dependencies required by your desktop product.&#160; These bootstrappers are unmanaged code, because you can’t always depend on the .NET framework already being there (at least not until everyone is off of XP and lower).&#160; I have developed a solution that has worked for the last year or more, but has felt clumsy and slapped together.&#160; Recently I found the <a href="http://dotnetinstaller.codeplex.com/">open source project called dotNetInstaller</a> which has better provided me with the control and flexibility I need for custom logic during bootstrap and install time.&#160; I’ll first introduce you to my “hack” solution.</p> <span class="fullpost">   <p>It has been difficult for me to find ways to tie into the bootstrapper logic workflow to add in custom logic during installs, and Visual Studio is very rigid in its flexibility and basic in its configuration options in this regard.&#160; Until recently, I had settled on writing managed, C# code for this custom logic meant to run before or after the MSI installer, and then creating another unmanaged <font face="Courier New">setup.exe</font> bootstrapper to ensure the .NET framework was installed just so that executable could run.&#160; So the user would run this new unmanaged <font face="Courier New">setup.exe</font> bootstrapper (making sure .NET framework was installed), which would then call my managed custom logic executable, which would then call the MSI installer’s unmanaged, Visual Studio-generated <font face="Courier New">setup.exe</font> bootstrapper (ensuring more prerequisites were installed), which would then finally install the MSI, and which would then lastly return to my managed custom logic executable for any post-install, clean up logic.&#160; I describe this solution in full (and how to generate the same bootstrappers that Visual Studio creates using MSBuild outside the IDE) in a StackOverflow.com answer that I submitted:</p>    <p><a title="http://stackoverflow.com/questions/1106768/how-can-i-reverse-engineer-an-installer-that-was-written-with-ghost-installer/1121846#1121846" href="http://stackoverflow.com/questions/1106768/how-can-i-reverse-engineer-an-installer-that-was-written-with-ghost-installer/1121846#1121846">http://stackoverflow.com/questions/1106768/how-can-i-reverse-engineer-an-installer-that-was-written-with-ghost-installer/1121846#1121846</a></p>    <p>Well, recently I found the <a href="http://dotnetinstaller.codeplex.com/">dotNetInstaller project on CodePlex.com</a> and have found it to be the control and flexibility I need for custom logic when bootstrapping installers.&#160; Not only does it give you great control over prerequisite install order, it also gives you the ability to run code after MSI install and to also filter on CPU architecture types, OS versions, and other registry or file system conditions.&#160; I have currently setup branching scenarios for the prerequisites based on if the user has a 32-bit (x86) or 64-bit (x64) OS.&#160; This utility will even let you brand the bootstrapper with a banner and icon, which is a change of pace from the plain and unlabeled bootstrapper that Visual Studio and MSBuild produce.</p>    <p>If you have custom bootstrapping needs, I have to highly recommend you give dotNetInstaller a look.&#160; Hopefully it will prove as flexible and powerful for your needs as it has for mine.</p> </span>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Display Name in Add/Remove Programs, MSI-Installed Products, and Compressed GUIDs]]></title>
    <link href="http://mkmurray.com/blog/2008/06/12/display-name-in-add-remove-programs-msi-installed-products-and-compressed-guids/"/>
    <updated>2008-06-12T15:52:00-06:00</updated>
    <id>http://mkmurray.com/blog/2008/06/12/display-name-in-add-remove-programs-msi-installed-products-and-compressed-guids</id>
    <content type="html"><![CDATA[<div class='post'>
<p>I was trying to rename a product's display name found in its ARP (Add/Remove Programs) entry.&#160; There is a registry key that lists just about every product installed on your machine:</p>  <p><font face="Courier New">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</font></p>  <p>Most (if not all) MSI-installed products have an entry under this key that is the <font face="Courier New">ProductCode</font> GUID.&#160; Every product under this key seems to have a <font face="Courier New">DisplayName</font> value, some of which you can modify and it will show the change in ARP.&#160; However, it appeared any product installed via MSI did not work this way.&#160; So I went registry hunting for any other entries the MSI installers might create.&#160; I found the following location:</p>  <p><font face="Courier New">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Installer</font></p>  <p>This key has many helpful sub-keys (including <font face="Courier New">Assemblies</font>, <font face="Courier New">Components</font>, <font face="Courier New">Features</font>, <font face="Courier New">Patches</font>, <font face="Courier New">Products</font>, and <font face="Courier New">UpgradeCodes</font>); the <font face="Courier New">Products</font> sub-key is the most important to me at the moment.&#160; Under this sub-key there are many entries (not as many as the first location I mentioned; these appear to MSI only products) that appear to be GUIDs without hyphens and braces.&#160; However, the key that represented the product I was interested in didn't match the <font face="Courier New">ProductCode</font> I had.&#160; But in one of the values, there was a <font face="Courier New">PackageCode</font> that was indeed the correct package GUID (different than <font face="Courier New">ProductCode</font>) and the <font face="Courier New">ProductName</font> matched as well.&#160; Turns out for MSI-installed products I could change this <font face="Courier New">ProductName</font> value and it would make the change to its ARP entry.</p> <span class='fullpost'> <p>But I was puzzled how I would know which entry to pick for any given product under this <font face="Courier New">Products</font> sub-key.&#160; I ended up coming across this blog post that explained what these different GUIDs are (called <font face="Courier New">Compressed GUIDs</font>); focus on the &quot;<strong>UPDATE</strong>&quot; section by John Walker:</p>  <p><a title="http://www.hanselman.com/blog/BATCHFILEVOODOODetermineIfMultipleAndWhichVersionsOfAnMSIinstalledProductAreInstalledUsingUpgradeCode.aspx" href="http://www.hanselman.com/blog/BATCHFILEVOODOODetermineIfMultipleAndWhichVersionsOfAnMSIinstalledProductAreInstalledUsingUpgradeCode.aspx">http://www.hanselman.com/blog/BATCHFILEVOODOODeterm.....UsingUpgradeCode.aspx</a></p>  <p>And then John Walker's update mentions this link that explains how to convert back and forth between regular and Compressed GUIDs:</p>  <p><a title="http://www.appdeploy.com/messageboards/tm.asp?m=11996&amp;mpage=1⼅" href="http://www.appdeploy.com/messageboards/tm.asp?m=11996&amp;mpage=1⼅">http://www.appdeploy.com/messageboards/tm.asp?m=11996&amp;mpage=1&amp;#12037</a></p>  <p>Basically you break up the GUID into groupings and reverse them.&#160; See below:</p>  <ul>   <li><u>Original GUID</u>:&#160; {abcdefgh-ijkl-mnop-qrst-uvwxyz123456} </li>    <li><u>Groupings</u>:&#160; abcdefgh ijkl mnop qr st uv wx yz 12 34 56 </li>    <li><u>Reversed Groupings</u>:&#160; hgfedcba lkji ponm rq ts vu xw zy 21 43 65 </li>    <li><u>Compressed GUID</u>:&#160; hgfedcbalkjiponmrqtsvuxwzy214365 </li> </ul>  <p>Don't know why Microsoft chose to butcher up GUIDs like this, but it's nice to know.</p> </span>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding Microsoft Office's Install Location]]></title>
    <link href="http://mkmurray.com/blog/2008/06/12/finding-microsoft-office-s-install-location/"/>
    <updated>2008-06-12T13:59:00-06:00</updated>
    <id>http://mkmurray.com/blog/2008/06/12/finding-microsoft-office-s-install-location</id>
    <content type="html"><![CDATA[<div class='post'>
<p>One of my co-workers, in trying to find the install location of <font face="Courier New">Microsoft Word</font>, found a cool little registry tree.&#160; Here is the key:</p>  <p><font face="Courier New">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Applications</font></p>  <p>Underneath this key, there are keys named <font face="Courier New">Winword.exe</font>, <font face="Courier New">EXCEL.EXE</font>, <font face="Courier New">Outlook.EXE</font>, <font face="Courier New">MSACCESS.EXE</font>, <font face="Courier New">POWERPNT.EXE</font>, <font face="Courier New">explorer.exe</font>, <font face="Courier New">iexplore.exe</font>, <font face="Courier New">AcroRD32.exe</font>, <font face="Courier New">iTunes.exe</font>, <font face="Courier New">javaw.exe</font>, and so on.&#160; It appears many of the big companies use this area to put information about how to do certain commands for a product from a shell (like open, edit, print, etc.).</p>  <p>My next post will be about another section under <font face="Courier New">SOFTWARE\Classes</font> that I discovered.</p>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Registry Launch Condition in VS 2005 Deployment Project]]></title>
    <link href="http://mkmurray.com/blog/2008/01/18/registry-launch-condition-in-vs-2005-deployment-project/"/>
    <updated>2008-01-18T17:09:00-07:00</updated>
    <id>http://mkmurray.com/blog/2008/01/18/registry-launch-condition-in-vs-2005-deployment-project</id>
    <content type="html"><![CDATA[<div class='post'>
<p>I have a Visual Studio 2005 deployment project where I wanted to add a launch condition that would check the registry for a key before continuing.&#160; This article is really straight forward about how to do that:&#160; <a title="http://msdn2.microsoft.com/en-us/library/4awx1f1d(VS.80).aspx" href="http://msdn2.microsoft.com/en-us/library/4awx1f1d(VS.80).aspx">http://msdn2.microsoft.com/en-us/library/4awx1f1d(VS.80).aspx</a></p>  <p>However, every time I put the registry path in, it would never find the key upon install.&#160; So the key was located at something like <font face="Courier New">HKLM\SOFTWARE\MyCompany\MyProduct</font> and then there was a Value named <font face="Courier New">Target Path</font> that I wanted to check if it existed.&#160; My understanding (and perhaps I'm wrong) that keys are keys but the values are keys also (at least it seems that way when doing registry stuff through the .NET APIs in C#).&#160; So when I saw the following statement in the above article, I thought the property was for testing the value of a <font face="Courier New">Value</font> (AKA key?):</p>  <blockquote>   <p><font face="Courier New">&quot;Optionally, set the <strong><u>Value</u></strong> property to search for a specific value in the registry key.&quot;</font></p> </blockquote>  <p>Essentially I tried to append the <font face="Courier New">Value</font> to the <font face="Courier New">RegKey</font> path, because I thought the <font face="Courier New">Value</font> property was only for testing the value of the <font face="Courier New">Value</font>.&#160; If you want to test the value of the <font face="Courier New">Value</font>, you do it in the <font face="Courier New">Condition</font> property of the <font face="Courier New">Property</font> created by the registry launch condition.&#160; Is that as clear as mud? </p>  <p>This article is what cleared up my confusion (the 2nd post, the one by Phil Wilson):&#160; <a title="http://www.dotnet247.com/247reference/msgs/49/246890.aspx" href="http://www.dotnet247.com/247reference/msgs/49/246890.aspx">http://www.dotnet247.com/247reference/msgs/49/246890.aspx</a> </p>  <p>I realized that a registry <font face="Courier New">Value</font> should not be part of the <font face="Courier New">RegKey</font> path.</p>  </div>

]]></content>
  </entry>
  
</feed>
